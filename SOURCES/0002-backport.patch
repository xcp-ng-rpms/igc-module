
### Backport code to kernel 4.19 by removing nerwer code that does not work
### in the older kernel and cange functions back to older ones that work in 4.19
### 	remove ETHTOOL_COALESCE_USECS
### 	remove TC_SETUP_QDISC_TAPRIO
### 	change net_prefetch to prefetch
### 	change netdev_xmit_more to skb->xmit_more
### 	change DPM_FLAG_NO_DIRECT_COMPLETE to DPM_FLAG_NEVER_SKIP
###
### Change MTU change notice to netdev_info becuase it's not debugging
###
###
### Change gettimex64 back to gettime64

--- a/igc_main.c	2022-09-28 09:10:41.000000000 +0000
+++ b/igc_main.c	2022-10-02 01:04:09.516114169 +0000
@@ -1190,7 +1190,7 @@
 	/* Make sure there is space in the ring for the next send. */
 	igc_maybe_stop_tx(tx_ring, DESC_NEEDED);
 
-	if (netif_xmit_stopped(txring_txq(tx_ring)) || !netdev_xmit_more()) {
+	if (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {
 		writel(i, tx_ring->tail);
 	}
 
@@ -1561,7 +1561,7 @@
 	struct sk_buff *skb;
 
 	/* prefetch first cache line of first page */
-	net_prefetch(va);
+	prefetch(va);
 
 	/* build an skb around the page buffer */
 	skb = build_skb(va - IGC_SKB_PAD, truesize);
@@ -1597,7 +1597,7 @@
 	struct sk_buff *skb;
 
 	/* prefetch first cache line of first page */
-	net_prefetch(va);
+	prefetch(va);
 
 	/* allocate a skb to store the frags */
 	skb = napi_alloc_skb(&rx_ring->q_vector->napi, IGC_RX_HDR_LEN);
@@ -1613,7 +1613,7 @@
 	/* Determine available headroom for copy */
 	headlen = size;
 	if (headlen > IGC_RX_HDR_LEN)
-		headlen = eth_get_headlen(skb->dev, va, IGC_RX_HDR_LEN);
+		headlen = eth_get_headlen(va, IGC_RX_HDR_LEN);
 
 	/* align pull length to size of long to optimize memcpy performance */
 	memcpy(__skb_put(skb, headlen), va, ALIGN(headlen, sizeof(long)));
@@ -3895,7 +3895,7 @@
 	if (netif_running(netdev))
 		igc_down(adapter);
 
-	netdev_dbg(netdev, "changing MTU from %d to %d\n", netdev->mtu, new_mtu);
+	netdev_info(netdev, "changing MTU from %d to %d\n", netdev->mtu, new_mtu);
 	netdev->mtu = new_mtu;
 
 	if (netif_running(netdev))
@@ -4726,59 +4726,6 @@
 	return 0;
 }
 
-static bool is_base_time_past(ktime_t base_time, const struct timespec64 *now)
-{
-	struct timespec64 b;
-
-	b = ktime_to_timespec64(base_time);
-
-	return timespec64_compare(now, &b) > 0;
-}
-
-static bool validate_schedule(struct igc_adapter *adapter,
-			      const struct tc_taprio_qopt_offload *qopt)
-{
-	int queue_uses[IGC_MAX_TX_QUEUES] = { };
-	struct timespec64 now;
-	size_t n;
-
-	if (qopt->cycle_time_extension)
-		return false;
-
-	igc_ptp_read(adapter, &now);
-
-	/* If we program the controller's BASET registers with a time
-	 * in the future, it will hold all the packets until that
-	 * time, causing a lot of TX Hangs, so to avoid that, we
-	 * reject schedules that would start in the future.
-	 */
-	if (!is_base_time_past(qopt->base_time, &now))
-		return false;
-
-	for (n = 0; n < qopt->num_entries; n++) {
-		const struct tc_taprio_sched_entry *e;
-		int i;
-
-		e = &qopt->entries[n];
-
-		/* i225 only supports "global" frame preemption
-		 * settings.
-		 */
-		if (e->command != TC_TAPRIO_CMD_SET_GATES)
-			return false;
-
-		for (i = 0; i < adapter->num_tx_queues; i++) {
-			if (e->gate_mask & BIT(i))
-				queue_uses[i]++;
-
-			if (queue_uses[i] > 1)
-				return false;
-		}
-	}
-
-	return true;
-}
-
 static int igc_tsn_enable_launchtime(struct igc_adapter *adapter,
 				     struct tc_etf_qopt_offload *qopt)
 {
@@ -4795,76 +4742,12 @@
 	return igc_tsn_offload_apply(adapter);
 }
 
-static int igc_save_qbv_schedule(struct igc_adapter *adapter,
-				 struct tc_taprio_qopt_offload *qopt)
-{
-	u32 start_time = 0, end_time = 0;
-	size_t n;
-
-	if (!qopt->enable) {
-		adapter->base_time = 0;
-		return 0;
-	}
-
-	if (adapter->base_time)
-		return -EALREADY;
-
-	if (!validate_schedule(adapter, qopt))
-		return -EINVAL;
-
-	adapter->cycle_time = qopt->cycle_time;
-	adapter->base_time = qopt->base_time;
-
-	/* FIXME: be a little smarter about cases when the gate for a
-	 * queue stays open for more than one entry.
-	 */
-	for (n = 0; n < qopt->num_entries; n++) {
-		struct tc_taprio_sched_entry *e = &qopt->entries[n];
-		int i;
-
-		end_time += e->interval;
-
-		for (i = 0; i < adapter->num_tx_queues; i++) {
-			struct igc_ring *ring = adapter->tx_ring[i];
-
-			if (!(e->gate_mask & BIT(i)))
-				continue;
-
-			ring->start_time = start_time;
-			ring->end_time = end_time;
-		}
-
-		start_time += e->interval;
-	}
-
-	return 0;
-}
-
-static int igc_tsn_enable_qbv_scheduling(struct igc_adapter *adapter,
-					 struct tc_taprio_qopt_offload *qopt)
-{
-	struct igc_hw *hw = &adapter->hw;
-	int err;
-
-	if (hw->mac.type != igc_i225)
-		return -EOPNOTSUPP;
-
-	err = igc_save_qbv_schedule(adapter, qopt);
-	if (err)
-		return err;
-
-	return igc_tsn_offload_apply(adapter);
-}
-
 static int igc_setup_tc(struct net_device *dev, enum tc_setup_type type,
 			void *type_data)
 {
 	struct igc_adapter *adapter = netdev_priv(dev);
 
 	switch (type) {
-	case TC_SETUP_QDISC_TAPRIO:
-		return igc_tsn_enable_qbv_scheduling(adapter, type_data);
-
 	case TC_SETUP_QDISC_ETF:
 		return igc_tsn_enable_launchtime(adapter, type_data);
 
@@ -5221,7 +5104,7 @@
 	pcie_print_link_status(pdev);
 	netdev_info(netdev, "MAC: %pM\n", netdev->dev_addr);
 
-	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);
+	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NEVER_SKIP);
 	/* Disable EEE for internal PHY devices */
 	hw->dev_spec._base.eee_enable = false;
 	adapter->flags &= ~IGC_FLAG_EEE;
diff -u -N -r igc-module-5.10.145/igc_ptp.c igc-module-5.10.146/igc_ptp.c
--- a/igc_ptp.c	2022-09-28 09:10:41.000000000 +0000
+++ b/igc_ptp.c	2022-10-02 00:10:57.441665064 +0000
@@ -83,21 +83,16 @@
 	return 0;
 }
 
-static int igc_ptp_gettimex64_i225(struct ptp_clock_info *ptp,
-				   struct timespec64 *ts,
-				   struct ptp_system_timestamp *sts)
+static int igc_ptp_gettime_i225(struct ptp_clock_info *ptp,
+				   struct timespec64 *ts)
 {
 	struct igc_adapter *igc = container_of(ptp, struct igc_adapter,
 					       ptp_caps);
-	struct igc_hw *hw = &igc->hw;
 	unsigned long flags;
 
 	spin_lock_irqsave(&igc->tmreg_lock, flags);
 
-	ptp_read_system_prets(sts);
-	ts->tv_nsec = rd32(IGC_SYSTIML);
-	ts->tv_sec = rd32(IGC_SYSTIMH);
-	ptp_read_system_postts(sts);
+	igc_ptp_read(igc, ts);
 
 	spin_unlock_irqrestore(&igc->tmreg_lock, flags);
 
@@ -493,7 +488,7 @@
 		adapter->ptp_caps.max_adj = 62499999;
 		adapter->ptp_caps.adjfine = igc_ptp_adjfine_i225;
 		adapter->ptp_caps.adjtime = igc_ptp_adjtime_i225;
-		adapter->ptp_caps.gettimex64 = igc_ptp_gettimex64_i225;
+		adapter->ptp_caps.gettime64 = igc_ptp_gettime_i225;
 		adapter->ptp_caps.settime64 = igc_ptp_settime_i225;
 		adapter->ptp_caps.enable = igc_ptp_feature_enable_i225;
 		break;
--- a/igc_ethtool.c	2022-09-28 09:10:41.000000000 +0000
+++ b/igc_ethtool.c	2022-10-02 01:03:02.876006970 +0000
@@ -1899,7 +1912,6 @@
 }
 
 static const struct ethtool_ops igc_ethtool_ops = {
-	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
 	.get_drvinfo		= igc_ethtool_get_drvinfo,
 	.get_regs_len		= igc_ethtool_get_regs_len,
 	.get_regs		= igc_ethtool_get_regs,
